pragma solidity ^0.8.13;

import {IButtonswapV2Pair} from
    "buttonswap-periphery_buttonswap-v2-core/interfaces/IButtonswapV2Pair/IButtonswapV2Pair.sol";
import {IERC20} from "../interfaces/IERC20.sol";
import {Math} from "buttonswap-periphery_buttonswap-v2-core/libraries/Math.sol";
import {PairMathV2} from "buttonswap-periphery_buttonswap-v2-core/libraries/PairMathV2.sol";

library ButtonswapV2Library {
    /// @notice Identical addresses provided
    error IdenticalAddresses(address token);
    /// @notice Zero address provided
    error ZeroAddress();
    //    /// @notice Insufficient amount provided
    //    error InsufficientAmount();
    //    /// @notice Insufficient liquidity provided
    //    error InsufficientLiquidity();
    //    /// @notice Insufficient input amount provided
    //    error InsufficientInputAmount();
    //    /// @notice Insufficient output amount provided
    //    error InsufficientOutputAmount();
    //    /// @notice Invalid path provided
    //    error InvalidPath();

    function decodeData(bytes memory data) internal pure returns (uint8 version, uint16 plBps, uint16 feeBps) {
        assembly {
            version := mload(add(data, 0x01))
            plBps := mload(add(data, 0x03))
            feeBps := mload(add(data, 0x05))
        }
    }

    /**
     * @dev Returns sorted token addresses, used to handle return values from pairs sorted in this order
     * @param tokenA First token address
     * @param tokenB Second token address
     * @return token0 First sorted token address
     * @return token1 Second sorted token address
     */
    function sortTokens(address tokenA, address tokenB) internal pure returns (address token0, address token1) {
        if (tokenA == tokenB) {
            revert IdenticalAddresses(tokenA);
        }
        (token0, token1) = tokenA < tokenB ? (tokenA, tokenB) : (tokenB, tokenA);
        // If the tokens are different and sorted, only token0 can be the zero address
        if (token0 == address(0)) {
            revert ZeroAddress();
        }
    }

    /**
     * @dev Predicts the address that the Pair contract for given tokens would have been deployed to
     * @dev Specifically, this calculates the CREATE2 address for a Pair contract.
     * @dev It's done this way to avoid making any external calls, and thus saving on gas versus other approaches.
     * @param factory The address of the ButtonswapV2Factory used to create the pair
     * @param tokenA First token address
     * @param tokenB Second token address
     * @param plBps The price-lowerbound of the pair in bps
     * @param feeBps The fee of the pair in bps
     * @return pair The pair address
     */
    function pairFor(address factory, address tokenA, address tokenB, uint16 plBps, uint16 feeBps)
        internal
        pure
        returns (address pair)
    {
        (address token0, address token1) = sortTokens(tokenA, tokenB);
        // Init Hash Code is generated by the following command:
        //        bytes32 initHashCode = keccak256(abi.encodePacked(type(ButtonswapV2Pair).creationCode));
        pair = address(
            uint160(
                uint256(
                    keccak256(
                        abi.encodePacked(
                            hex"ff",
                            factory,
                            keccak256(abi.encodePacked(token0, token1, plBps, feeBps)),
                            hex"0ad32f62449f817a4ea99994ea69522b04f1926685c6025bd048f21b3ba1b68c" // init code hash
                        )
                    )
                )
            )
        );
    }

    /**
     * @dev Fetches and sorts the pools for a pair. Pools are the current token balances in the pair contract serving as liquidity.
     * @param factory The address of the ButtonswapV2Factory
     * @param tokenA First token address
     * @param tokenB Second token address
     * @param plBps The price-lowerbound of the pair in bps
     * @param feeBps The fee of the pair in bps
     * @return poolA Pool corresponding to tokenA
     * @return poolB Pool corresponding to tokenB
     */
    function getPools(address factory, address tokenA, address tokenB, uint16 plBps, uint16 feeBps)
        internal
        view
        returns (uint256 poolA, uint256 poolB)
    {
        (address token0,) = sortTokens(tokenA, tokenB);
        (uint256 pool0, uint256 pool1,,,,,) =
            IButtonswapV2Pair(pairFor(factory, tokenA, tokenB, plBps, feeBps)).getLiquidityBalances();
        (poolA, poolB) = tokenA == token0 ? (pool0, pool1) : (pool1, pool0);
    }

    /**
     * @dev Fetches and sorts the pools for a provided pair address. Pools are the current token balances in the pair contract serving as liquidity.
     * @param pair The address of the pair
     * @param tokenA First token address
     * @param tokenB Second token address
     * @return poolA Pool corresponding to tokenA
     * @return poolB Pool corresponding to tokenB
     */
    function getPoolsFromPair(address pair, address tokenA, address tokenB)
        internal
        view
        returns (uint256 poolA, uint256 poolB)
    {
        (address token0,) = sortTokens(tokenA, tokenB);
        (uint256 pool0, uint256 pool1,,,,,) = IButtonswapV2Pair(pair).getLiquidityBalances();
        (poolA, poolB) = tokenA == token0 ? (pool0, pool1) : (pool1, pool0);
    }

    function kDMult(uint256 plBps, uint256 scalar) internal pure returns (uint256 _kDMult) {
        _kDMult = Math.sqrt(plBps * (1e4 - plBps) * (1e4 - plBps)) * scalar;
    }

    function getAmountOut(uint256 amountIn, uint256 poolIn, uint256 poolOut, uint256 plBps, uint256 feeBps)
        internal
        pure
        returns (uint256 amountOut)
    {
        if (plBps == 0) {
            // Scale everything up to take the fee into account
            amountIn = amountIn * (1e4 - feeBps);
            poolIn = poolIn * 1e4;
            poolOut = poolOut * 1e4;

            // Calculate amountOut
            amountOut = (amountIn * poolOut) / (poolIn + amountIn);
        } else {
            // Calculate unscaled knOld before scaling
            uint256 knOld = PairMathV2.kN(poolIn, poolOut, plBps);

            // Scale everything up to take the fee into account
            amountIn = amountIn * (1e4 - feeBps);
            poolIn = poolIn * 1e4;
            poolOut = poolOut * 1e4;
            uint256 s1 = Math.sqrt(plBps * knOld * knOld) * 1e4;
            knOld = knOld * 1e4;

            {
                uint256 numerator = (kDMult(plBps, 100 * poolOut) + s1) * amountIn;
                uint256 denominator = kDMult(plBps, 100 * poolIn) + s1 + kDMult(plBps, 100 * amountIn);
                amountOut = numerator / denominator;
            }

            // If the amountOut exceeds poolOut, then return poolOut
            if (amountOut > poolOut - 1) {
                amountOut = poolOut - 1;
            }
            // Check if we've lowered the k-invariant (from precision errors).
            // If we have, then we need to return some of the amountOut
            amountOut = amountOut - (amountOut % 1e4);
            uint256 knNew = PairMathV2.kN(poolIn + amountIn, poolOut - amountOut, plBps);
            if (knNew < knOld) {
                uint256 s = Math.mulDiv(knOld, 2 ** 112, knNew);
                uint256 returnAmount = Math.mulDiv(
                    s * s - 2 ** 224,
                    kDMult(plBps, 100 * poolOut) - kDMult(plBps, 100 * amountOut) + s1,
                    kDMult(plBps, 100) * 2 ** 224
                );
                amountOut -= returnAmount;
            }
        }
        // Scale the amountOut back down
        amountOut = (amountOut) / 1e4;
    }

    function getAmountIn(uint256 amountOut, uint256 poolIn, uint256 poolOut, uint256 plBps, uint256 feeBps)
        internal
        pure
        returns (uint256 amountIn)
    {
        // Can't take out more than the pool has
        assert(amountOut <= poolOut);

        if (plBps == 0) {
            // Scale everything up to take the fee into account
            amountOut = amountOut * 1e4;
            poolIn = poolIn * 1e4;
            poolOut = poolOut * 1e4;

            // Calculate amountIn
            amountIn = (poolIn * amountOut) / (poolOut - amountOut) + (1e4 - feeBps);
        } else {
            // Calculate unscaled knOld before scaling
            uint256 knOld = PairMathV2.kN(poolIn, poolOut, plBps);

            // Scale everything up to take the fee into account
            amountOut = amountOut * 1e4;
            poolIn = poolIn * 1e4;
            poolOut = poolOut * 1e4;
            uint256 s1 = Math.sqrt(plBps * knOld * knOld) * 1e4;
            knOld = knOld * 1e4;
            {
                uint256 numerator = (kDMult(plBps, 100 * poolIn) + s1) * amountOut;
                uint256 denominator = kDMult(plBps, 100 * poolOut) + s1 - kDMult(plBps, 100 * amountOut);
                amountIn = numerator / denominator;
            }

            // Check if we've lowered the k-invariant (from precision errors).
            // If we have, then we need to add more of the amountIn
            amountIn = ((amountIn + (1e4 - feeBps - 1)) / (1e4 - feeBps)) * (1e4);
            uint256 knNew = PairMathV2.kN(poolIn + amountIn, poolOut - amountOut, plBps);
            if (knNew < knOld) {
                uint256 s = Math.mulDiv(knOld, 2 ** 112, knNew);
                uint256 returnAmount = Math.mulDiv(
                    s * s - 2 ** 224,
                    kDMult(plBps, 100 * poolIn) + kDMult(plBps, 100 * amountIn) + s1,
                    kDMult(plBps, 100) * 2 ** 224
                );
                amountIn += returnAmount;
            }
            knNew = PairMathV2.kN(poolIn + amountIn, poolOut - amountOut, plBps);
        }
        // Scale the amountIn back down
        amountIn = amountIn / (1e4 - feeBps);
    }
}
